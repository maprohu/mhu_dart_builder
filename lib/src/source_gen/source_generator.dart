import 'dart:io';

import 'package:dart_style/dart_style.dart';
import 'package:mhu_dart_commons/commons.dart';

import 'generic.dart';
import 'prop.dart';
import 'typ.dart';


const result = 'R\$';
const item = 'I\$';
final itemGeneric = Generic.simple(item);
final itemTyp = Typ(withoutNullability: item, nullable: false);
final itemProp = Prop(
  name: 'item',
  type: itemTyp,
);

const fallbackVar = 'fallback';

final resultTyp = Typ(withoutNullability: result, nullable: false);
final resultGeneric = Generic.simple(result);

extension _DirectoryX on Directory {
  Directory dir(String path) => Directory.fromUri(uri.resolve(path));
  File file(String name) => File.fromUri(uri.resolve(name));
}

File createGeneratedFile(String fileName, SourceWriter writer,
    {Directory? targetDir}) {
  targetDir ??= Directory.current.dir('lib').dir('generated');
  assert(targetDir.existsSync());
  final targetFile = targetDir.file(fileName);
  final fileHeader = '// generated $fileName';

  print('Generating: ${targetFile.uri}');

  if (targetFile.existsSync()) {
    final lines = targetFile.readAsLinesSync();
    assert(
        lines[0] == fileHeader, 'Header of generated file is not: $fileHeader');
  }

  writer.line(fileHeader);

  return targetFile;
}

extension SourceWriterStringIterableX on Iterable<String> {
  String get commas => join(', ');

  Iterable<String> get plusCommas => map((e) => '$e,');

  String joinEnclosed(
    String start,
    String end, [
    String sep = '',
  ]) =>
      isEmpty ? '' : '$start${join(sep)}$end';

  String commasEnclosed(
    String start, [
    String end = '',
  ]) =>
      joinEnclosed(start, end, ', ');

  String joinCurlySep([String sep = '']) => joinEnclosed('{', '}', sep);

  String joinSquareSep([String sep = '']) => joinEnclosed('[', ']', sep);

  String get curlyIfNotEmpty => joinCurlySep();

  String get squareIfNotEmpty => joinSquareSep();

  String get commasGenerics => commasEnclosed('<', '>');
}

class SourceWriter {
  final _lines = <String>[];

  int _indent = 0;

  void line(String line) {
    final indent = List.filled(_indent, '  ').join();
    _lines.add('$indent$line');
  }

  void block(
    String header,
    void Function() content,
  ) {
    line("$header {");
    indented(content);
    line("}");
  }

  void indented(void Function() content, {int level = 1}) {
    indent();
    content();
    outdent();
  }

  String get content => _lines.join("\n");

  void indent({int level = 1}) => _indent += level;

  void outdent({int level = 1}) => _indent -= level;
}

mixin Id {
  String get name;

  String get cap => name.capitalize();

  String get uncap => name.uncapitalize();

  @override
  String toString() => name;
}

class Ctx<T, C> {
  final T value;
  final C ctx;

  Ctx(this.value, this.ctx);

  @override
  String toString() => value.toString();
}

class ClassDef with Id {
  @override
  final String name;

  ClassDef(this.name);
}

class DotGeneration {
  final Directory directory;
  final String name;
  final String? handWrittenFileHeader;
  late final Directory dartToolDirectory;

  DotGeneration._(
    this.directory,
    this.name, {
    Directory? dartToolDirectory,
    this.handWrittenFileHeader,
  }) {
    this.dartToolDirectory =
        dartToolDirectory ?? Directory.current.dir('.dart_tool');
  }

  late final generatedFileName = "$name.gen.dart";

  late final handwrittenFileName = "$name.dart";

  late final handwrittenFile = directory.file(handwrittenFileName);

  late final generatedFile = directory.file(generatedFileName);

  final writer = SourceWriter();

  late final errorDirectory = dartToolDirectory
      .dir('dot_generation')
      .also((d) => d.createSync(recursive: true));

  late final errorFile = errorDirectory.file(generatedFileName);

  void _prepare() {
    print('Generating: ${generatedFile.uri}');

    directory.createSync(recursive: true);

    final fileHeader = '// generated $generatedFileName';

    final targetFile = generatedFile;
    if (targetFile.existsSync()) {
      final lines = targetFile.readAsLinesSync();
      assert(
        lines[0] == fileHeader,
        'Header of generated file is not: $fileHeader',
      );
    }

    if (!handwrittenFile.existsSync()) {
      final writer = SourceWriter();
      handWrittenFileHeader?.let(writer.line);
      writer.line("part '$generatedFileName';");
      handwrittenFile.writeAsStringSync(writer.content);
    }

    writer.line(fileHeader);
    writer.line("// generated by ${Platform.script}");
    writer.line("part of '$handwrittenFileName';");
  }

  factory DotGeneration(
    String name, {
    Directory? directory,
    String? handWrittenFileHeader,
  }) {
    directory ??= Directory.current.dir('lib').dir('generated');

    return DotGeneration._(
      directory,
      name,
      handWrittenFileHeader: handWrittenFileHeader,
    ).._prepare();
  }

  void writeGeneratedFile() {
    try {
      final formatted = _formatter.format(writer.content);
      generatedFile.writeAsStringSync(formatted);
    } catch (e) {
      stderr.write(e);
      errorFile.writeAsStringSync(writer.content);
      stderr.write(errorFile.uri);
    }
  }
}

final _formatter = DartFormatter();


extension BuilderStringX on String {
  String get curly => '{$this}';

  String get square => '[$this]';

  String andParen(Iterable<String> items) => '$this${items.paren}';

  String andCurly(Iterable<String> items) => '$this${items.curly}';

  String andSquare(Iterable<String> items) => '$this${items.square}';

  String andParenCurly(Iterable<String> items) => '$this${items.curly.paren}';

  String get chevrons => '<$this>';

  String get angled => chevrons;

  String get genericsBrackets => chevrons;

  String get andSemi => '$this;';

  String get andDollar => '$this\$';
  String get andDot => '$this.';

  String get andComma => '$this,';

  String followedBy(String str) => '$this$str';

  String callMethod(
    String nameAndGenerics, [
    Iterable<String> args = const Iterable.empty(),
  ]) =>
      followedBy('.$nameAndGenerics').andParen(args);

  String get thisRef => 'this.$this';

  String formattedDartCode([File? errorOutput]) {
    try {
      return _formatter.format(this);
    } catch (_) {
      if (errorOutput != null) {
        errorOutput.writeAsString(this);
        stderr.writeln("error formatting: ${errorOutput.uri}");
      }
      rethrow;
    }
  }
}

extension BuilderStringIterableX on Iterable<String> {
  String get curly => join().curly;

  String get paramsCurly => curlyIfNotEmpty;

  String get square => join().square;

  String get paren => join().paren;

// String get genericsBrackets => join(", ").genericsBrackets;
}

extension BuilderStringBufferX on StringBuffer {
  void block(String header, Iterable<String> content) =>
      write([header, content.curly].join());

  void paren(String header, Iterable<String> content) =>
      write([header, content.paren].join());
}
